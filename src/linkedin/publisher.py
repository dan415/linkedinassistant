import json
import logging
import os
import requests

from src.utils.log_handler import TruncateByTimeHandler

PWD = os.path.dirname(os.path.abspath(__file__))
PROJECT_DIR = os.path.abspath(os.path.join(PWD, '..', ".."))
LOGGING_DIR = os.path.join(PROJECT_DIR, "logs") if os.name != 'nt' else os.path.join(r"C:\\", "ProgramData", "linkedin_assistant", "logs")
FILE = os.path.basename(__file__)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
handler = TruncateByTimeHandler(filename=os.path.join(LOGGING_DIR, f'{FILE}.log'), encoding='utf-8', mode='a+')
handler.setLevel(logging.INFO)
handler.setFormatter(logging.Formatter(f'%(asctime)s - %(name)s - {__name__} - %(levelname)s - %(message)s'))
logger.addHandler(handler)
config_dir = os.path.join(r"C:\\", "ProgramData", "linkedin_assistant", "linkedin", "config.json") if os.name == 'nt' else os.path.join(PWD, "config.json")

class LinkedinPublisher:

    """
    Publishes content to linkedin.
    """

    def __init__(self):
        self.client_id = ""
        self.client_secret = ""
        self.redirect_uri = ""
        self.linkedin_id = ""
        self.access_token = None
        self.footer = ""
        self.reload_config()

    def needs_auth(self):
        """
        Check if the publisher needs to get the authorization.
        :return:
        """
        return not self.access_token

    def post(self, content):
        """
        Post the content to linkedin. If it does not have an access token it will redirect you to log in first

        I use the footer to explicitly say that the content is generated by AI. Also, I make use of the
        Linkedin API V2 to post the content, throough ugcPosts.

        :param content:  content to post.
        :return:
        """
        self.reload_config()
        if not self.access_token:
            logger.error("Access token not found")
            return False


        content += self.footer # Add the footer to the content, I use it to explicitly say that the content is
        # generated by AI
        if self.access_token:
            logger.info("Posting to linkedin")
            api_url = 'https://api.linkedin.com/v2/ugcPosts'

            headers = {
                'Authorization': f'Bearer {self.access_token}',
                'Connection': 'Keep-Alive',
                'Content-Type': 'application/json',
            }

            data = {
                "author": f"urn:li:person:{self.linkedin_id}",
                "lifecycleState": "PUBLISHED",
                "specificContent": {
                    "com.linkedin.ugc.ShareContent": {
                        "shareCommentary": {
                            "text": content
                        },
                        "shareMediaCategory": "NONE"
                    }
                },
                "visibility": {
                    "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"
                }
            }

            response = requests.post(api_url, headers=headers, json=data)
            if response.status_code == 201:
                logger.info("Posted to linkedin")
                return True
            else:
                logger.error("Error posting to linkedin: %s", response.status_code)
                self.access_token = None
                self.update_config()
                return False
        else:
            logger.error("Access token not found")
            return False

    def update_config(self):
        """
        Update the configuration.
        :return:
        """
        logger.debug("Updating config")
        with open(config_dir, "r") as f:
            config = json.load(f)
        new_config = {}
        for key in config.keys():
            new_config[key] = self.__getattribute__(key)

        with open(config_dir, "w") as f:
            json.dump(new_config, f)

    def reload_config(self):
        """
        Reload the configuration.
        :return:
        """
        """Reload the configuration."""
        logger.debug("Reloading config")
        with open(config_dir, "r") as f:
            config = json.load(f)

        for key in config.keys():
            self.__setattr__(key, config[key])
