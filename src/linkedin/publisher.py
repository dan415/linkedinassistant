from typing import Optional

import requests
from src.core.config.manager import ConfigManager
from .constants import *
from src.core.vault.hvault import VaultClient
import src.core.utils.functions as F
from ..core.vault.exceptions import VaultError

FILE = os.path.basename(__file__)
logger = F.get_logger(dump_to=FILE)

class LinkedinPublisher:
    """
    Publishes content to linkedin.
    """

    def __init__(self):
        self.client_id = ""
        self.client_secret = ""
        self.redirect_uri = ""
        self.linkedin_id = ""
        self.access_token = None
        self.footer = ""
        self.config_client = ConfigManager()
        self.vault_client = VaultClient()
        self.reload_config()

    def needs_auth(self):
        """
        Check if the publisher needs to get the authorization.
        :return:
        """
        return not self.access_token

    def post(self, content, asset: Optional[str]):
        """
        Post the content to linkedin. If it does not have an access token it will redirect you to log in first

        I use the footer to explicitly say that the content is generated by AI. Also, I make use of the
        Linkedin API V2 to post the content, through ugcPosts.

        :param asset:
        :param content:  content to post.
        :return:
        """
        self.reload_config()

        if not self.access_token:
            logger.error("No access token available")
            return False

        post_data = {
            "author": f"urn:li:person:{self.linkedin_id}",
            "lifecycleState": "PUBLISHED",
            "specificContent": {
                "com.linkedin.ugc.ShareContent": {
                    "shareCommentary": {
                        "text": f"{content}\n\n{self.footer}"
                    },
                }
            },
            "visibility": {
                "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"
            }
        }

        if asset:
            post_data["specificContent"]["com.linkedin.ugc.ShareContent"]["shareMediaCategory"] = "IMAGE"
            post_data["specificContent"]["com.linkedin.ugc.ShareContent"]["media"] = [{
                "status": "READY",
                "description": {
                    "text": "Generated image for the post"
                },
                "media": asset,
            }]
        else:
            post_data["specificContent"]["com.linkedin.ugc.ShareContent"]["shareMediaCategory"] = "NONE"

        try:
            response = requests.post(LINKEDIN_SHARE_URL, headers=self.get_headers(), json=post_data)
            if response.status_code == 201:
                logger.info("Posted to linkedin")
                return True
            else:
                logger.error(f"Failed to post: {response.status_code} - {response.text}")
                self.access_token = None
                self.update_config()
                return False
        except Exception as e:
            logger.error(f"Failed to post: {str(e)}")
            return False

    def get_headers(self, content_type: Optional[str] = 'application/json'):
        res = {'Authorization': f'Bearer {self.access_token}'}
        if content_type:
            res['Content-Type'] = content_type
        return res

    def register_image_upload(self):
        register_upload_body = {
            "registerUploadRequest": {
                "recipes": ["urn:li:digitalmediaRecipe:feedshare-image"],
                "owner": f"urn:li:person:{self.linkedin_id}",
                "serviceRelationships": [{
                    "relationshipType": "OWNER",
                    "identifier": "urn:li:userGeneratedContent"
                }]
            }
        }

        upload_response = requests.post(LINKEDIN_REGISTER_UPLOAD_URL, json=register_upload_body, headers=self.get_headers())
        upload_response.raise_for_status()
        return upload_response.json()

    def upload_image(self, image_data):
        # First, register the image upload
        upload_data = self.register_image_upload()

        # Upload the image binary
        asset = upload_data['value']['asset']
        upload_url = upload_data['value']['uploadMechanism']['com.linkedin.digitalmedia.uploading.MediaUploadHttpRequest'][
                'uploadUrl']

        binary_upload_response = requests.post(
            upload_url,
            data=image_data,
            headers=self.get_headers(content_type=None)
        )
        binary_upload_response.raise_for_status()
        return asset

    def publish_with_image(self, content, image_data):
        """
        Publish content with an image to LinkedIn.
        
        :param content: The text content to post
        :param image_data: Image bytes
        :return: True if successful, False otherwise
        """
        if self.needs_auth():
            return False

        try:
            asset = self.upload_image(image_data)
            return self.post(content, asset)

        except Exception as e:
            logger.error(f"Failed to publish with image: {str(e)}")
            return False

    def update_config(self):
        """
        Update the configuration.
        :return:
        """
        logger.debug("Updating config")
        config = self.config_client.load_config(LINKEDIN_CONFIG_SCHEMA)
        new_config = {}
        for key in config.keys():
            new_config[key] = self.__getattribute__(key)

        self.config_client.save_config(LINKEDIN_CONFIG_SCHEMA, config)

    def reload_config(self):
        """
        Reload the configuration from the config file.
        :return:
        """
        logger.debug("Reloading config")
        config = self.config_client.load_config(LINKEDIN_CONFIG_SCHEMA)
        for key in config.keys():
            self.__setattr__(key, config[key])

        self.client_id = self.vault_client.get_secret(LINKEDIN_CLIENT_ID_KEY)
        self.client_secret = self.vault_client.get_secret(LINKEDIN_CLIENT_SECRET_KEY)
        self.redirect_uri = "https://" + self.vault_client.get_secret(LINKEDIN_REDIRECT_URI_KEY)
        self.linkedin_id = self.vault_client.get_secret(LINKEDIN_ID_KEY)
        try:
            self.access_token = self.vault_client.get_secret(LINKEDIN_ACCESS_TOKEN_KEY)
        except VaultError as ex:
            logger.warning(f"Access token not found in vault: {ex}")
            self.access_token = None
